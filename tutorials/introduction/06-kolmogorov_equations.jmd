---
title:  Kolmogorov Backward Equations
author: Ashutosh Bharambe
---

```julia
using Flux, StochasticDiffEq
using  NeuralNetDiffEq
using Plots
using Distributions
```
## Introduction on Kolmogorov Equations

The one dimensional backward kolmogorov equation that we are going to deal with is of the form :
$$
\begin{equation}
  \frac{\partial p}{\partial t} = \mu(x)\frac{\partial p}{\partial x} + \frac{1}{2}{\sigma^2}(x)\frac{\partial^2 p}{\partial x^2}
\end{equation}
$$
Consider a Black Scholes Partial Differential Equation of the form :
$$
\begin{equation}
  \frac{\partial V}{\partial t} + rS\frac{\partial V}{\partial S} + \frac{1}{2}{\sigma^2}{S^2}\frac{\partial^2 V}{\partial S^2} -rV = 0
\end{equation}
$$

In order to make the above equation in the form of the Backward - Kolmogorov PDE we should substitute

$$
\begin{equation}
  V(S , t) = e^{rt}p(S , t)
\end{equation}
$$
$$
\begin{equation}
  p(S , T) = max\{ x - \mathcal{K} , 0 \}
\end{equation}
$$
We will train our model and the model itself will be the solution of the equation
## Defining the problem and the solver
We should start defining the terminal condition for our equation:
```julia
function phi(xi)
    y = Float64[]
    K = 100
    for x in eachcol(xi)
        val = max(K - maximum(x) , 0.00)
        y = push!(y , val)
    end
    y = reshape(y , 1 , size(y)[1] )
    return y
end
```
Now we shall define the problem :
We will define the σ and μ by comparing it to the orignal equation.
```julia
d = 1
r = 0.04
sigma = 0.4
xspan = (95.00 , 110.0)
tspan = (0.0 , 1.0)
σ(du , u , p , t) = du .= sigma.*u
μ(du , u , p , t) = du .= r.*u
prob = KolmogorovPDEProblem(μ , σ , phi , xspan , tspan, d)

```
Now once we have defined our problem it is necessary to define the parameters for the solver.
```julia
sdealg = EM()
ensemblealg = EnsembleThreads()
dt = 0.01
dx = 0.001
trajectories = 100000
```

Now lets define our model m and the optimiser
```julia
m = Chain(Dense(d, 32, leakyrelu),Dense(32, 64, leakyrelu),Dense(64 , 32 , leakyrelu) , Dense(32 , 1))
m = fmap(cu , m)
opt = Flux.ADAM(0.01)
```
And then finally call the solver
```julia
sol = solve(prob, NeuralNetDiffEq.NNKolmogorov(m, opt, sdealg, ensemblealg), verbose = true, dt = dt,
            dx = dx , trajectories = trajectories , abstol=1e-6, maxiters = 3000)
```
## Analyzing the solution
Now let us find a Monte-Carlo Solution and plot the both:
```julia
monte_carlo_sol = []
x_out = collect(98:1.00:105.00)
for x in x_out
  u₀= [x]
  g_val(du , u , p , t) = 0.4.*u
  f_val(du , u , p , t) = du .= 0.04.*u
  dt = 0.01
  tspan = (0.0,1.0)
  prob = SDEProblem(f_val,g_val,u₀,tspan)
  output_func(sol,i) = (sol[end],false)
  ensembleprob_val = EnsembleProblem(prob , output_func = output_func )
  sim_val = solve(ensembleprob_val, EM(), EnsembleThreads() , dt=0.01, trajectories=100000,adaptive=false)
  s = reduce(hcat , sim_val.u)
  global monte_carlo_sol = push!(monte_carlo_sol , mean(phi(s)))
end
```

##Plotting the Solutions
We should reshape the inputs and outputs to make it compatible with our model
```julia
x_model = reshape(x_out, 1 , size(x_out)[1])
y_out = m(x_model)
y_out = reshape(y_out , 13 , 1)
```
And now finally we can plot the solutions
```julia
plot(x_out , y_out , lw = 3 ,  xaxis="Initial Stock Price", yaxis="Payoff")
plot!(x_out , monte_carlo_sol , lw = 3 ,  xaxis="Initial Stock Price", yaxis="Payoff")
```
